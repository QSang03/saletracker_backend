import { Injectable, Logger, Inject, forwardRef } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from '../users/user.entity';
import { UserStatusObserver } from '../observers/user-status.observer';
import { SystemConfig } from '../system_config/system_config.entity';

@Injectable()
export class ZaloLinkMonitorCronjob {
  private readonly logger = new Logger(ZaloLinkMonitorCronjob.name);
  private isRunning = false; // Lock ƒë·ªÉ tr√°nh duplicate execution

  constructor(
    @InjectRepository(User)
    private readonly userRepo: Repository<User>,
    @InjectRepository(SystemConfig)
    private readonly systemConfigRepo: Repository<SystemConfig>,
    @Inject(forwardRef(() => UserStatusObserver))
    private readonly userStatusObserver: UserStatusObserver,
  ) {
    this.logger.log('üöÄ ZaloLinkMonitorCronjob kh·ªüi ƒë·ªông');
  }

 
  @Cron(process.env.ZALO_LINK_MONITOR_CRON || '*/5 * * * *')
  async monitorZaloLinkStatus() {
    // Ki·ªÉm tra lock ƒë·ªÉ tr√°nh duplicate execution
    if (this.isRunning) {
      this.logger.warn(`‚ö†Ô∏è Cronjob ƒëang ch·∫°y, b·ªè qua l·∫ßn n√†y ƒë·ªÉ tr√°nh duplicate`);
      return;
    }

    // Ki·ªÉm tra th·ªùi gian ngh·ªâ
    const isInRestTime = await this.checkRestTime();
    if (isInRestTime) {
      this.logger.log(`üò¥ B·ªè qua cronjob - ƒëang trong th·ªùi gian ngh·ªâ`);
      return;
    }

    this.isRunning = true;
    const startTime = Date.now();
    
    try {
        // L·∫•y t·∫•t c·∫£ user c√≥ zalo_link_status = 2 (l·ªói li√™n k·∫øt) v√† kh√¥ng b·ªã ban (is_block = false)
      const allUsersWithError = await this.userRepo.find({
        where: { 
          zaloLinkStatus: 2,
          isBlock: false // Ch·ªâ l·∫•y user kh√¥ng b·ªã ban
        },
        select: ['id', 'username', 'fullName', 'email', 'employeeCode', 'zaloLinkStatus', 'isBlock', 'updatedAt']
      });

      // L·ªçc b·ªè user thietpn v√† user kh√¥ng c√≥ email
      const usersWithError = allUsersWithError.filter(user => 
        user.username !== 'thietpn' && 
        user.email !== 'thietpn@nguyenkimvn.vn' &&
        user.email && user.email.trim() !== ''
      );

      this.logger.log(`üìä T√¨m th·∫•y ${allUsersWithError.length} users c√≥ l·ªói li√™n k·∫øt, sau khi l·ªçc thietpn v√† kh√¥ng c√≥ email c√≤n ${usersWithError.length} users`);

      for (const user of usersWithError) {
        // G·ªçi API Python ƒë·ªÉ x·ª≠ l√Ω l·ªói li√™n k·∫øt
        await this.handleZaloLinkError(user);
      }

    } catch (error) {
      this.logger.error(`L·ªói khi monitor Zalo link status: ${error.message}`);
    } finally {
      // Lu√¥n reset lock trong finally block
      this.isRunning = false;
    }
  }

  private async handleZaloLinkError(user: User) {
    try {
      // Trigger notifyUserStatusChange ƒë·ªÉ handleUserStatusChange x·ª≠ l√Ω
      await this.userStatusObserver.notifyUserStatusChange(
        user.id,
        user.zaloLinkStatus, // Tr·∫°ng th√°i hi·ªán t·∫°i
        2, // L·ªói li√™n k·∫øt
        'database_monitor'
      );
    } catch (error) {
      this.logger.error(`L·ªói khi x·ª≠ l√Ω l·ªói li√™n k·∫øt cho user ${user.id}: ${error.message}`);
    }
  }

  // Reset lock n·∫øu b·ªã stuck
  resetLock() {
    this.isRunning = false;
  }

  // Ki·ªÉm tra th·ªùi gian ngh·ªâ
  private async checkRestTime(): Promise<boolean> {
    try {
      const config = await this.systemConfigRepo.findOne({
        where: { name: 'system_stopToolConfig' }
      });

      if (!config || !config.value) {
        this.logger.log('Kh√¥ng t√¨m th·∫•y config system_stopToolConfig, cho ph√©p ch·∫°y');
        return false;
      }

      const schedule = JSON.parse(config.value);
      const now = new Date();
      const currentDay = now.toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase();
      const currentTime = now.toLocaleTimeString('en-US', { 
        hour12: false, 
        hour: '2-digit', 
        minute: '2-digit' 
      });

      // Ki·ªÉm tra ng√†y hi·ªán t·∫°i c√≥ trong schedule kh√¥ng
      if (!schedule[currentDay]) {
        this.logger.log(`Ng√†y ${currentDay} kh√¥ng c√≥ trong schedule, cho ph√©p ch·∫°y`);
        return false;
      }

      // Ki·ªÉm tra th·ªùi gian hi·ªán t·∫°i c√≥ n·∫±m trong kho·∫£ng ngh·ªâ kh√¥ng
      const daySchedule = schedule[currentDay];
      for (const timeSlot of daySchedule) {
        if (this.isTimeInRange(currentTime, timeSlot.start, timeSlot.end)) {
          this.logger.log(`Th·ªùi gian hi·ªán t·∫°i ${currentTime} n·∫±m trong kho·∫£ng ngh·ªâ ${timeSlot.start}-${timeSlot.end}`);
          return true;
        }
      }

      this.logger.log(`Th·ªùi gian hi·ªán t·∫°i ${currentTime} kh√¥ng n·∫±m trong kho·∫£ng ngh·ªâ, cho ph√©p ch·∫°y`);
      return false;

    } catch (error) {
      this.logger.error(`L·ªói khi ki·ªÉm tra th·ªùi gian ngh·ªâ: ${error.message}`);
      return false; // N·∫øu c√≥ l·ªói, cho ph√©p ch·∫°y
    }
  }

  // Ki·ªÉm tra th·ªùi gian c√≥ n·∫±m trong kho·∫£ng kh√¥ng
  private isTimeInRange(currentTime: string, startTime: string, endTime: string): boolean {
    const current = this.timeToMinutes(currentTime);
    const start = this.timeToMinutes(startTime);
    const end = this.timeToMinutes(endTime);

    if (start <= end) {
      // Kho·∫£ng th·ªùi gian trong c√πng 1 ng√†y (v√≠ d·ª•: 12:00-13:30)
      return current >= start && current <= end;
    } else {
      // Kho·∫£ng th·ªùi gian qua ng√†y (v√≠ d·ª•: 23:00-07:00)
      return current >= start || current <= end;
    }
  }

  // Chuy·ªÉn ƒë·ªïi th·ªùi gian th√†nh ph√∫t ƒë·ªÉ so s√°nh
  private timeToMinutes(time: string): number {
    const [hours, minutes] = time.split(':').map(Number);
    return hours * 60 + minutes;
  }
}
