import { Injectable, Logger } from '@nestjs/common';
import { Cron } from '@nestjs/schedule';
import { HttpService } from '@nestjs/axios';
import { firstValueFrom } from 'rxjs';
import { ConfigService } from '@nestjs/config';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { NKCProduct } from '../nkc_products/nkc_product.entity';
import { Category } from '../categories/category.entity';
import { DebtStatistic } from '../debt_statistics/debt_statistic.entity';
import { Debt } from '../debts/debt.entity';

@Injectable()
export class CronjobService {
  private readonly logger = new Logger(CronjobService.name);

  constructor(
    private readonly httpService: HttpService,
    private readonly configService: ConfigService,
    @InjectRepository(NKCProduct)
    private readonly nkcProductRepo: Repository<NKCProduct>,
    @InjectRepository(Category)
    private readonly categoryRepo: Repository<Category>,
    @InjectRepository(DebtStatistic)
    private debtStatisticRepo: Repository<DebtStatistic>,
    @InjectRepository(Debt)
    private debtRepo: Repository<Debt>,
  ) {
    this.logger.log(
      'üéØ [CronjobService] Service ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o - Cronjob debt statistics s·∫Ω ch·∫°y l√∫c 11h tr∆∞a h√†ng ng√†y',
    );
  }

  @Cron(process.env.CRON_DEBT_STATISTICS_TIME || '0 23 * * *')
  async handleDebtStatisticsCron() {
    // S·ª≠ d·ª•ng timezone Vi·ªát Nam (UTC+7)
    const today = new Date();
    const vietnamTime = new Date(today.getTime() + (7 * 60 * 60 * 1000)); // Add 7 hours
    const todayStr = vietnamTime.toISOString().split('T')[0]; // Format: YYYY-MM-DD
    const vietnamDate = new Date(todayStr); // Parse as date for comparison

    this.logger.log(
      `üîÑ [Auto Cron] B·∫Øt ƒë·∫ßu capture debt statistics cho ng√†y: ${todayStr}`,
    );

    try {
      // Ki·ªÉm tra ƒë√£ c√≥ data cho ng√†y h√¥m nay ch∆∞a
      const existingCount = await this.debtStatisticRepo.count({
        where: { statistic_date: vietnamDate },
      });

      if (existingCount > 0) {
        this.logger.log(
          `‚ö†Ô∏è [Auto Cron] ƒê√£ c√≥ ${existingCount} b·∫£n ghi cho ng√†y ${todayStr}, b·ªè qua`,
        );
        return;
      }

      // Raw query ƒë·ªÉ copy ALL debts sang debt_statistics m·ªói ng√†y
      // QUAN TR·ªåNG: Duplicate t·∫•t c·∫£ phi·∫øu ƒë·ªÉ c√≥ th·ªëng k√™ ch√≠nh x√°c
      const query = `
        INSERT INTO debt_statistics (
          statistic_date, customer_raw_code, invoice_code, bill_code,
          total_amount, remaining, issue_date, due_date, pay_later,
          status, sale_id, sale_name_raw, employee_code_raw,
          debt_config_id, customer_code, customer_name, note,
          is_notified, original_created_at, original_updated_at, original_debt_id
        )
        SELECT 
          ? as statistic_date,
          d.customer_raw_code, d.invoice_code, d.bill_code,
          d.total_amount, d.remaining, d.issue_date, d.due_date, d.pay_later,
          d.status, d.sale_id, d.sale_name_raw, d.employee_code_raw,
          d.debt_config_id, dc.customer_code, dc.customer_name, d.note,
          d.is_notified, d.created_at, d.updated_at, d.id
        FROM debts d
        LEFT JOIN debt_configs dc ON d.debt_config_id = dc.id
        WHERE d.deleted_at IS NULL
      `;

      const result = await this.debtStatisticRepo.query(query, [todayStr]);

      this.logger.log(
        `‚úÖ [Auto Cron] ƒê√£ l∆∞u ${result.affectedRows || 0} b·∫£n ghi cho ng√†y ${todayStr}`,
      );
    } catch (error) {
      this.logger.error(
        `‚ùå [Auto Cron] L·ªói khi capture debt statistics:`,
        error,
      );
    }
  }

  // Method ƒë·ªÉ ch·∫°y th·ªß c√¥ng - c√≥ th·ªÉ ch·∫°y b·∫•t c·ª© khi n√†o
  async captureDebtStatisticsManual(targetDate?: string) {
    // S·ª≠ d·ª•ng timezone Vi·ªát Nam (UTC+7) n·∫øu kh√¥ng c√≥ targetDate
    let dateToCapture: string;
    if (targetDate) {
      dateToCapture = targetDate;
    } else {
      const now = new Date();
      const vietnamTime = new Date(now.getTime() + (7 * 60 * 60 * 1000)); // Add 7 hours
      dateToCapture = vietnamTime.toISOString().split('T')[0];
    }
    
    const captureDate = new Date(dateToCapture);
    captureDate.setHours(0, 0, 0, 0);

    this.logger.log(
      `üîÑ [Th·ªëng k√™ c√¥ng n·ª£ - Th·ªß c√¥ng] B·∫Øt ƒë·∫ßu capture cho ng√†y: ${dateToCapture}`,
    );

    try {
      // Ki·ªÉm tra ƒë√£ c√≥ data cho ng√†y n√†y ch∆∞a
      const existingCount = await this.debtStatisticRepo.count({
        where: { statistic_date: captureDate },
      });

      if (existingCount > 0) {
        this.logger.log(
          `‚ö†Ô∏è [Th·ªëng k√™ c√¥ng n·ª£ - Th·ªß c√¥ng] ƒê√£ c√≥ ${existingCount} b·∫£n ghi cho ng√†y ${dateToCapture}`,
        );
        return {
          success: false,
          message: `ƒê√£ c√≥ d·ªØ li·ªáu th·ªëng k√™ cho ng√†y ${dateToCapture}`,
          existingRecords: existingCount,
        };
      }

      const query = `
        INSERT INTO debt_statistics (
          statistic_date, customer_raw_code, invoice_code, bill_code,
          total_amount, remaining, issue_date, due_date, pay_later,
          status, sale_id, sale_name_raw, employee_code_raw,
          debt_config_id, customer_code, customer_name, note,
          is_notified, original_created_at, original_updated_at, original_debt_id
        )
        SELECT 
          ? as statistic_date,
          d.customer_raw_code, d.invoice_code, d.bill_code,
          d.total_amount, d.remaining, d.issue_date, d.due_date, d.pay_later,
          d.status, d.sale_id, d.sale_name_raw, d.employee_code_raw,
          d.debt_config_id, dc.customer_code, dc.customer_name, d.note,
          d.is_notified, d.created_at, d.updated_at, d.id
        FROM debts d
        LEFT JOIN debt_configs dc ON d.debt_config_id = dc.id
        WHERE d.deleted_at IS NULL
      `;

      this.logger.log(
        `üíæ [Th·ªëng k√™ c√¥ng n·ª£ - Th·ªß c√¥ng] ƒêang capture T·∫§T C·∫¢ debts hi·ªán c√≥ cho ng√†y ${dateToCapture}...`,
      );

      const result = await this.debtStatisticRepo.query(query, [dateToCapture]);

      this.logger.log(
        `‚úÖ [Th·ªëng k√™ c√¥ng n·ª£ - Th·ªß c√¥ng] ƒê√£ l∆∞u ${result.affectedRows || 0} b·∫£n ghi cho ng√†y ${dateToCapture}`,
      );

      return {
        success: true,
        message: `Capture th√†nh c√¥ng ${result.affectedRows || 0} debt statistics`,
        recordsSaved: result.affectedRows || 0,
        date: dateToCapture,
        note: 'Duplicate t·∫•t c·∫£ phi·∫øu c√¥ng n·ª£ hi·ªán c√≥ cho ng√†y n√†y',
      };
    } catch (error) {
      this.logger.error(
        `‚ùå [Th·ªëng k√™ c√¥ng n·ª£ - Th·ªß c√¥ng] L·ªói khi capture debt statistics:`,
        error,
      );
      return {
        success: false,
        message: `L·ªói khi capture debt statistics: ${error.message}`,
        error: error.message,
      };
    }
  }

  @Cron(process.env.CRON_PRODUCT_TIME || '0 2 * * *')
  async fetchAndSaveProducts() {
    const baseUrl = process.env.VNK_API_PRODUCT_URL!;
    const perPage = Number(process.env.VNK_API_PRODUCT_PER_PAGE) || 500;
    const token = this.configService.get<string>('VNK_API_TOKEN')!;
    const concurrency = 5;

    this.logger.log(`[ProductSync] Start product sync...`);

    // L·∫•y s·∫£n ph·∫©m t·ª´ API
    const allProducts: any[] = [];
    const apiIds = new Set<number>();
    let page = 1;
    let done = false;
    while (!done) {
      const pages = Array.from({ length: concurrency }, (_, idx) => page + idx);
      const results = await Promise.all(
        pages.map((p) => this.fetchPage(baseUrl, token, perPage, p)),
      );
      for (const [idx, products] of results.entries()) {
        if (!products.length) {
          done = true;
          break;
        }
        allProducts.push(...products);
        products.forEach((item) => apiIds.add(item.product_id));
      }
      page += concurrency;
    }
    this.logger.log(`[ProductSync] Fetched ${allProducts.length} products.`);

    // Upsert s·∫£n ph·∫©m m·ªõi/c·∫≠p nh·∫≠t
    const upsertBatch = allProducts.map((item) => ({
      id: item.product_id,
      productCode: item.MaHH,
      productName: item.TenHH,
      properties: item.properties,
      deletedAt: undefined,
    }));
    await this.nkcProductRepo.upsert(upsertBatch, ['id']);
    this.logger.log(`[ProductSync] Upserted ${upsertBatch.length} products.`);

    // X√ìA M·ªÄM: ƒê√°nh d·∫•u deletedAt cho s·∫£n ph·∫©m kh√¥ng c√≤n trong API
    const deleteBatchSize = 1000;
    let dbOffset = 0;
    let hasMore = true;
    let deletedCount = 0;
    while (hasMore) {
      const dbProducts = await this.nkcProductRepo.find({
        select: ['id'],
        skip: dbOffset,
        take: deleteBatchSize,
      });
      if (!dbProducts.length) break;
      for (const dbProduct of dbProducts) {
        if (!apiIds.has(dbProduct.id)) {
          await this.nkcProductRepo.update(dbProduct.id, {
            deletedAt: new Date(),
          });
          deletedCount++;
        }
      }
      dbOffset += deleteBatchSize;
      hasMore = dbProducts.length === deleteBatchSize;
    }
    this.logger.log(
      `[ProductSync] Soft-deleted ${deletedCount} products not found in API.`,
    );
    this.logger.log(`[ProductSync] Product sync completed.`);
  }

  // H√†m l·∫•y 1 trang s·∫£n ph·∫©m
  private async fetchPage(
    baseUrl: string,
    token: string,
    perPage: number,
    page: number,
  ) {
    const url = `${baseUrl}?search=&per_page=${perPage}&page=${page}`;
    try {
      const res = await firstValueFrom(
        this.httpService.get(url, {
          headers: { Authorization: `Bearer ${token}` },
        }),
      );
      return res.data?.data?.data || [];
    } catch (error) {
      this.logger.error(
        `[ProductSync] Error fetching page ${page}: ${error.message}`,
      );
      return [];
    }
  }

  @Cron(process.env.CRON_CATEGORY_TIME || '0 3 * * *') // th·ªùi gian l·∫•y t·ª´ env
  async fetchAndSaveCategories() {
    const url = this.configService.get<string>('VNK_API_CATEGORY_URL')!;
    const token = this.configService.get<string>('VNK_API_TOKEN')!;
    const response = await firstValueFrom(
      this.httpService.get(url, {
        headers: { Authorization: `Bearer ${token}` },
      }),
    );
    const categories: any[] = response.data?.data || [];
    type FlatCategory = { id: number; catName: string; parent: number | null };
    const flatCategories: FlatCategory[] = [];
    function flatten(cat: any, parentId: number | null = null) {
      flatCategories.push({
        id: cat.cat_id,
        catName: cat.cat_name,
        parent: parentId,
      });
      if (cat.children && Array.isArray(cat.children)) {
        for (const child of cat.children) {
          flatten(child, cat.cat_id);
        }
      }
    }
    for (const cat of categories) {
      flatten(cat, null);
    }
    const apiIds = flatCategories.map((c) => c.id);
    for (const cat of flatCategories) {
      await this.categoryRepo.upsert(
        {
          id: cat.id,
          catName: cat.catName,
          deletedAt: undefined,
          parent: cat.parent ? { id: cat.parent } : undefined,
        },
        ['id'],
      );
    }
    // Batch check for deleted
    const batchSize = 1000;
    let deletedCatCount = 0;
    let dbOffset = 0;
    let hasMore = true;
    while (hasMore) {
      const dbCats = await this.categoryRepo.find({
        select: ['id'],
        skip: dbOffset,
        take: batchSize,
      });
      if (!dbCats.length) break;
      for (const dbCat of dbCats) {
        if (!apiIds.includes(dbCat.id)) {
          await this.categoryRepo.update(dbCat.id, { deletedAt: new Date() });
          deletedCatCount++;
        }
      }
      dbOffset += batchSize;
      hasMore = dbCats.length === batchSize;
    }
    this.logger.log(
      `Ho√†n t·∫•t ƒë·ªìng b·ªô danh m·ª•c. ƒê√£ l∆∞u ${flatCategories.length} danh m·ª•c, ƒë√°nh d·∫•u x√≥a ${deletedCatCount} danh m·ª•c kh√¥ng c√≤n trong API.`,
    );
  }
}
